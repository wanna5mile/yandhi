<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Yandhi Music Player</title>
    <link rel="icon" href="disc.png" type="image/png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
      html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
      #renderCanvas { width: 100%; height: 100%; touch-action: none; }
      .player-controls {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 20px;
        z-index: 10;
      }
      .player-controls button {
        background: rgba(0, 0, 0, 0.6);
        border: none;
        color: white;
        border-radius: 50%;
        width: 70px;
        height: 70px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        transition: all 0.2s ease;
      }
      .player-controls button:hover {
        transform: scale(1.1);
        background: rgba(255, 255, 255, 0.15);
      }
      #playBtn { width: 90px; height: 90px; }
      .player-controls button.active {
        background: rgba(0, 170, 255, 0.6);
        box-shadow: 0 0 15px rgba(0, 170, 255, 0.9);
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>

    <div class="player-controls">
      <button id="shuffleBtn"><i class="fas fa-random fa-2x"></i></button>
      <button id="prevBtn"><i class="fa fa-step-backward fa-2x"></i></button>
      <button id="playBtn"><i class="fa fa-play-circle fa-5x"></i></button>
      <button id="nextBtn"><i class="fa fa-step-forward fa-2x"></i></button>
      <button id="repeatBtn"><i class="fas fa-redo fa-2x"></i></button>
    </div>

<audio id="audio" preload="auto"></audio>
<script src="https://cdn.babylonjs.com/babylon.js"></script>

<!--EVENTS AND BUILD HERE DAWG -->
<script>
// ✅ SINGLE-FILE WORKING MUSIC PLAYER (RESTORED + MERGED + STABLE)
// Drop this in event.js and REMOVE other JS imports

window.addEventListener("DOMContentLoaded", () => {

  const waitForBabylon = setInterval(() => {
    if (!window.BABYLON) return;
    clearInterval(waitForBabylon);
    
    // ✅ GLOBAL TEXTURE ORIENTATION FIX
    BABYLON.Texture.FlipY = false;

    // ================= AUDIO SETUP =================
    const canvas = document.getElementById("renderCanvas");
    const audio = document.getElementById("audio");

    const playlist = ["./assets/music/byebyebaby.mp3"];
    let currentIndex = 0;
    let isPlaying = false;

    audio.src = playlist[currentIndex];

    // ================= BUTTONS =================
    const playBtn = document.getElementById("playBtn");
    const nextBtn = document.getElementById("nextBtn");
    const prevBtn = document.getElementById("prevBtn");
    const shuffleBtn = document.getElementById("shuffleBtn");
    const repeatBtn = document.getElementById("repeatBtn");
    const playIcon = playBtn.querySelector("i");

    let shuffle = false;
    let repeat = false;

    // ================= BABYLON ENGINE =================
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);

    const camera = new BABYLON.ArcRotateCamera(
      "camera",
      Math.PI / 2,
      Math.PI / 2.5,
      8,
      BABYLON.Vector3.Zero(),
      scene
    );
    camera.attachControl(canvas, true);

    // Lighting
    const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
    hemiLight.intensity = 0.4;

    const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.5), scene);
    dirLight.position = new BABYLON.Vector3(5, 8, 5);
    dirLight.intensity = 1.2;

    const pointLight = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(0, 2, -3), scene);
    pointLight.intensity = 0.6;

    // ================= DISC =================
    const discBody = BABYLON.MeshBuilder.CreateCylinder("discBody", {
      height: 0.05,
      diameter: 3,
      tessellation: 96
    }, scene);

    discBody.position.x = 0;
    discBody.position.z = -0.2;

    const hole = BABYLON.MeshBuilder.CreateCylinder("hole", {
      height: 0.06,
      diameter: 0.2, // EDIT THIS TWIN
      tessellation: 64
    }, scene);

    hole.position.x = 0;
    hole.position.z = -0.2;

    const discCSG = BABYLON.CSG.FromMesh(discBody).subtract(BABYLON.CSG.FromMesh(hole));
    const disc = discCSG.toMesh("disc", null, scene);

    discBody.dispose();
    hole.dispose();

    disc.rotation.x = Math.PI / 2;

    const discMat = new BABYLON.PBRMaterial("discMat", scene);
    discMat.albedoTexture = new BABYLON.Texture("disc.png", scene);
    discMat.backFaceCulling = true;
    discMat.metallic = 0.4;
    discMat.roughness = 0.25;
    discMat.clearCoat.isEnabled = true;
    discMat.clearCoat.intensity = 0.8;
    disc.material = discMat;

// ---------------- GLOBAL HELPER: create a StandardMaterial that respects PNG alpha ----------------
function makeStandardTextureMaterial(name, url, scene, opts = {}) {
  const mat = new BABYLON.StandardMaterial(name, scene);

  // Make sure the texture loads and uses its alpha channel
  const tex = new BABYLON.Texture(url, scene);
  tex.hasAlpha = true;                     // important: treat PNG alpha as real alpha
  mat.diffuseTexture = tex;

  // Show texture colors without tinting
  mat.diffuseColor = new BABYLON.Color3(1, 1, 1);

  // Use the texture alpha to drive material transparency
  mat.useAlphaFromDiffuseTexture = true;

  // Choose alpha blend mode so partially transparent pixels render smoothly
  mat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;

  // Optional: show both sides of thin planes (useful for flat boxes / quads)
  mat.backFaceCulling = true;

  // If you want lighting to not darken the texture too much, you can tweak:
  // mat.specularColor = new BABYLON.Color3(0,0,0); // optional: reduce specular shine
  // mat.emissiveColor = new BABYLON.Color3(1,1,1); // optional: make texture unaffected by lights

  // Extra: allow flipping/rotation options via opts (uScale/vScale/wAng/uOffset/vOffset)
  if (opts.uScale !== undefined) tex.uScale = opts.uScale;
  if (opts.vScale !== undefined) tex.vScale = opts.vScale;
  if (opts.uOffset !== undefined) tex.uOffset = opts.uOffset;
  if (opts.vOffset !== undefined) tex.vOffset = opts.vOffset;
  if (opts.wAng !== undefined) { tex.uRotationCenter = 0.5; tex.vRotationCenter = 0.5; tex.wAng = opts.wAng; }
  if (opts.uScaleMirror) { tex.uScale = -Math.abs(tex.uScale || 1); tex.uOffset = 1; }

  return mat;
}

// ---------------- USAGE: replace your material construction with the helper ----------------

// eighty
const eighty = BABYLON.MeshBuilder.CreateBox("eighty", {
  width: 0.8,
  height: 0.8,
  depth: 0.05
}, scene);

eighty.position.x = -1.5;
eighty.position.y = 1.5;
eighty.position.z = -0.2;

const eightyMat = makeStandardTextureMaterial("eightyMat", "80fix.png", scene);
eighty.material = eightyMat;

// insert (vertical, not upside down, side-loaded)
const insert = BABYLON.MeshBuilder.CreateBox("insert", {
  width: 0.5,
  height: 1.2,
  depth: 0.05
}, scene);

insert.position.x = 1.8;
insert.position.y = 1.4;
insert.position.z = -0.2;

const insertMat = makeStandardTextureMaterial(
  "insertMat",
  "insertfix.png",
  scene,
  {
    wAng: Math.PI / 2,   // rotate 90° clockwise so it's vertical
    vScale: -1           // fixes upside-down
  }
);

insert.material = insertMat;

// minidisc (correct orientation)
const minidisc = BABYLON.MeshBuilder.CreateBox("minidisc", {
  width: 0.8,
  height: 0.8,
  depth: 0.05
}, scene);

minidisc.position.x = 0;
minidisc.position.y = -1.2;
minidisc.position.z = -0.1;

const minidiscMat = makeStandardTextureMaterial(
  "minidiscMat",
  "minidiscfix.png",
  scene,
  {
    vScale: -1   // ✅ flips vertically to fix upside-down rendering
  }
);

minidisc.material = minidiscMat;

// ================= CASE + TAPE (WAS MISSING - CAUSED CRASH) =================
const tape = BABYLON.MeshBuilder.CreateBox("tape", {
  width: 1.4,
  height: 4 / 3,
  depth: 0.2
}, scene);

tape.position.x = -1.4;
tape.position.z = -0.2;

const caseBox = BABYLON.MeshBuilder.CreateBox("case", {
  width: 4,
  height: 4,
  depth: 0.15
}, scene);

// Glass material for case
const glassMat = new BABYLON.PBRMaterial("glassMat", scene);
glassMat.alpha = 0.25;
glassMat.indexOfRefraction = 1.5;
glassMat.roughness = 0.05;
caseBox.material = glassMat;
caseBox.position.z = -0.2;

const tapeMat = new BABYLON.StandardMaterial("tapeMat", scene);
tapeMat.diffuseColor = new BABYLON.Color3(0.75, 0.6, 0.9); // if you want colored tape
tapeMat.backFaceCulling = true;
tape.material = tapeMat;

    // ================= AUDIO ANALYSER =================
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioCtx.createAnalyser();
    const src = audioCtx.createMediaElementSource(audio);
    src.connect(analyser);
    analyser.connect(audioCtx.destination);

    const dataArray = new Uint8Array(analyser.frequencyBinCount);

    // ================= CONTROLS =================
    playBtn.onclick = () => {
      audioCtx.resume();

      if (!isPlaying) {
        audio.play();
        isPlaying = true;
        playIcon.classList.replace("fa-play-circle", "fa-pause-circle");
      } else {
        audio.pause();
        isPlaying = false;
        playIcon.classList.replace("fa-pause-circle", "fa-play-circle");
      }
    };

    nextBtn.onclick = () => {
      currentIndex = shuffle
        ? Math.floor(Math.random() * playlist.length)
        : (currentIndex + 1) % playlist.length;

      audio.src = playlist[currentIndex];
      audio.play();
      isPlaying = true;
    };

    prevBtn.onclick = () => {
      currentIndex = (currentIndex - 1 + playlist.length) % playlist.length;
      audio.src = playlist[currentIndex];
      audio.play();
      isPlaying = true;
    };

    shuffleBtn.onclick = () => {
      shuffle = !shuffle;
      shuffleBtn.classList.toggle("active", shuffle);
    };

    repeatBtn.onclick = () => {
      repeat = !repeat;
      repeatBtn.classList.toggle("active", repeat);
      audio.loop = repeat;
    };

    audio.addEventListener("ended", () => {
      if (!repeat) nextBtn.onclick();
    });

    // ================= RENDER LOOP =================
    engine.runRenderLoop(() => {
      if (isPlaying) {
        analyser.getByteFrequencyData(dataArray);
        const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
        disc.rotate(BABYLON.Axis.Y, 0.01 + avg * 0.0003, BABYLON.Space.LOCAL);
      }
      scene.render();
    });

    window.addEventListener("resize", () => engine.resize());

  }, 10);

});
</script>

  <script src="yandhi-player.js" defer></script>
  </body>
</html>
